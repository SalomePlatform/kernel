<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.73 [en] (WinNT; I) [Netscape]">
   <title>Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>
&nbsp;
<center><table WIDTH="96%" >
<tr>
<td><a href="http://www.opencascade.com"><img SRC="sources/logocorp.gif" BORDER=0 height=46 width=122></a></td>

<td>
<div align=right><a href="http://www.opencascade.org/SALOME/"><img SRC="sources/application.gif" BORDER=0 height=46 width=108></a></div>
</td>
</tr>
</table></center>
<a NAME="page1"></a>
<h2>
Mapping of IDL definitions to Python language.</h2>
<a NAME="Intro"></a>
<h2>
Introduction</h2>
SALOME is a distributed client/server application using the Common
Object Request Broker Architecture (CORBA). CORBA architecture uses the
Interface Definition Language (IDL), which specifies interfaces between
CORBA objects. So with help of IDL CORBA's language independence is ensured
. Because interfaces described in IDL can be mapped to the most of currently
used programming languages, CORBA applications and components are thus
independent of the language(s) used to implement them. In other words,
a client written in C++ can communicate with a server written in Java,
which in turn can communicate with another server written in COBOL, and
so forth.
<p>One important thing to remember about IDL is that it is not an implementation
language. That is, applications can't be written in IDL. The sole purpose
of IDL is to define interfaces; providing implementations for these interfaces
is performed using some other language.
<p>This page contains an abridged reference manual for mapping of IDL definitions
to Python language. It will be useful for Python programmers who are not
familiar with IDL language. All examples are taken from SALOME source
files. The complete version of Python Language Mapping Specification can
be found <a href="http://www.omg.org" target="top">here.</a>
<br>&nbsp;
<p><a NAME="contents"></a><b>CONTENTS:</b>
<ul>&nbsp;
<li>
<a href="#subsection1">Using Scoped Names</a></li>

<li>
<a href="#subsection2">Mapping for Template and Array Types</a></li>

<li>
<a href="#subsection3">Mapping for Objects and Operations</a></li>

<li>
<a href="#subsection4">Narrowing Object References</a></li>

<li>
<a href="#subsection5">Mapping for Exceptions</a></li>

<li>
<a href="#subsection6">Mapping for Enumeration Types</a></li>

<li>
<a href="#subsection7">Mapping for Structured Types</a></li>
</ul>
<br>
<a NAME="subsection1"></a>
<h3>
Using Scoped Names</h3>
Python implements a module concept that is similar to the IDL scoping mechanisms,
except that it does not allow for nested modules. In addition, Python requires
each object to be implemented in a module; globally visible objects are
not supported.
<p>Because of these constraints, scoped names are translated into Python
using the following rules:
<p>• An IDL module mapped into a Python module. Modules containing modules
are mapped to packages (i.e., directories with an <b>__init__</b> module
containing all definitions excluding the nested modules). An implementation
can chose to map toplevel definitions (including the module CORBA) to modules
in an implementationdefined package, to allow concurrent installations
of different CORBA runtime libraries. In that case, the implementation
must provide additional modules so that toplevel modules can be used without
importing them from a package.
<p>• For all other scopes, a Python class is introduced that contains all
the definitions inside this scope.
<p>• Other global definitions (except modules) appear in a module whose
name is implementation dependent. Implementations are encouraged to use
the name of the IDL file when defining the name of that module.
<p>For instance,
<div class="fragment">
<pre>module SALOMEDS {
&nbsp;interface StudyManager {
&nbsp; void&nbsp; Close(in Study aStudy);
&nbsp;};
};</pre>
</div>
would introduce a module SALOMEDS.py, which contains the following definitions:
<div class="fragment">
<pre># module SALOMEDS.py
class StudyManager:
&nbsp; def _Close(self,aStudy):
&nbsp;&nbsp; pass #interfaces are discussed later</pre>
</div>
To avoid conflicts, IDL names that are also Python identifiers are prefixed
with an underscore (‘_’).
<p><b><i><a href="#contents">Back to the contents</a></i></b><b><i></i></b>
<p><a NAME="subsection2"></a>
<h3>
Mapping for Template and Array Types</h3>
Both the bounded and the unbounded string type of IDL are mapped to the
Python string type. Wide strings are represented by an implementation-defined
type with the following properties:
<p>• For the wide string X and the integer n, X[n] returns the nth character,
which is a wide string of length 1.
<p>• len(X) returns the number of characters of wide string X.
<p>• CORBA.wstr(c) returns a wide character with the code point c in an
implementation-defined encoding.
<p>• X+Y returns the concatenation of wide strings X and Y.
<p>• CORBA.word(CORBA.wstr(c)) == c
<p>The sequence template is mapped to sequence objects (e.g., tuples or
lists). Applications should not assume that values of a sequence type are
mutable. Sequences and arrays of octets and characters are mapped to the
string type for efficiency reasons.
<p>For example, given the IDL definitions
<div class="fragment">
<pre>module SALOMEDS {
&nbsp; typedef sequence &lt;string> StringSeq;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; interface AttributeTableOfInteger : GenericAttribute {

&nbsp;&nbsp;&nbsp; void SetRowTitles(in StringSeq theTitles) raises(IncorrectArgumentLength);
&nbsp;};
};</pre>
</div>
a client could invoke the operation
<div class="fragment">
<pre>print My_AttributeTableOfInteger.SetRowTitles(["X","F"])</pre>
</div>
Array types are mapped like sequence templates. The application in this
example also expects an IncorrectArgumentLength exception if it passes
sequences that violate the bounds constraint or arrays of wrong size.
<p>Another example with arrays. The following IDL definition
<div class="fragment">
<pre>module SALOMEDS {
&nbsp;typedef sequence&lt;GenericAttribute> ListOfAttributes;
&nbsp;interface SObject {
&nbsp; ListOfAttributes&nbsp;&nbsp;&nbsp;&nbsp; GetAllAttributes();
&nbsp;};
};</pre>
</div>
is equal to
<div class="fragment">
<pre>import SALOMEDS

attributes=[]
&nbsp;
attributes = My_SObject.GetAllAttributes()

length = len(attributes)

print "Attributes number = ", length
print attributes</pre>
</div>
<b><i><a href="#contents">Back to the contents</a></i></b>
<p><a NAME="subsection3"></a>
<h3>
Mapping for Objects and Operations</h3>
A CORBA object reference is represented as a Python object at run-time.
This object provides all the operations that are available on the interface
of the object. Although this specification does not mandate the use of
classes for stub objects, the following discussion uses classes to indicate
the interface.
<p>The nil object is represented by <b>None</b>.
<p>If an operation expects parameters of the IDL Object type, any Python
object representing an object reference might be passed as actual argument.
<p>If an operation expects a parameter of an abstract interface, either
an object implementing that interface, or a value supporting this interface
may be passed as actual argument. The semantics of abstract values then
define whether the argument is passed by value or by reference.
<p>Operations of an interface map to methods available on the object references.
Parameters with a parameter attribute of <b>in</b> or <b>inout</b> are
passed from left to right tothe method, skipping <b>out</b> parameters.
The return value of a method depends on the number of <b>out</b> parameters
and the return type. If the operation returns a value, this value forms
the first <i>result value</i>. All <b>inout</b> or <b>out</b> parameters
form consecutive <i>result values</i>. The method result depends then on
the number of <i>result values</i>:
<p>• If there is no <i>result value</i>, the method returns None.
<p>• If there is exactly one <i>result value</i>, it is returned as a single
value.
<p>• If there is more than one <i>result value</i>, all of them are packed
into a tuple, and this tuple is returned.
<p>Assuming the IDL definition
<div class="fragment">
<pre>module SALOMEDS{
&nbsp;interface StudyBuilder{
&nbsp; boolean FindAttribute&nbsp; ( in SObject anObject,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out GenericAttribute anAttribute,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in string aTypeOfAttribute );
&nbsp;};
};</pre>
</div>
a client could write
<div class="fragment">
<pre>from SALOMEDS import StudyBuilder;
my_StudyBuilder=...
&nbsp;&nbsp;
&nbsp; res,A=my_StudyBuilder.FindAttribute(Sobj, "AttributeSequenceOfReal")</pre>
</div>
In this example <b>A</b> corresponds to the return value <b>anAttribute</b>
and <b>res</b> to the <b>boolean</b> return value.
<p>If an interface defines an <b>attribute name</b>, for example, the attribute
is mapped into an operation <b>_get_name</b>. If the attribute is not <b>readonly</b>,
there is an additional operation <b>_set_name</b>.
<p>The IDL definition
<div class="fragment">
<pre>module SALOMEDS{
&nbsp;interface Study{
&nbsp; attribute string Name;
&nbsp;};
};</pre>
</div>
is equal to the following
<div class="fragment">
<pre>from SALOMEDS import Study
My_Study=...
&nbsp; Name=My_Study._get_name();
&nbsp; Name=My_Study._set_name();</pre>
</div>
<b><i><a href="#contents">Back to the contents</a></i></b><b><i><a href="#contents"></a></i></b>
<p><a NAME="subsection4"></a>
<h3>
Narrowing Object References</h3>
Python objects returned from CORBA operations or pseudo-operations (such
as string_to_object) might have a dynamic type, which is more specific
than the static type as defined in the operation signature.
<p>Since there is no efficient and reliable way of automatically creating
the most specific type, explicit narrowing is necessary. To narrow an object
reference <b>A</b> to an interface class <b>AttributeSequenceOfReal</b>,
the client can use the following operation
<div class="fragment">
<pre>A = A._narrow(SALOMEDS.AttributeSequenceOfReal)</pre>
</div>
<b><i><a href="#contents">Back to the contents</a></i></b><b><i><a href="#contents"></a></i></b>
<p><a NAME="subsection5"></a>
<h3>
Mapping for Exceptions</h3>
An IDL exception is translated into a Python class derived from CORBA.UserException.
System exceptions are derived from CORBA.SystemException. Both base classes
are derived from CORBA.Exception. The parameters of the exception are mapped
in the same way as the fields of a struct definition. When raising an exception,
a new instance of the class is created; the constructor expects the exception
parameters. For example, the definition
<div class="fragment">
<pre>module SALOMEDS{
&nbsp;interface StudyBuilder{
&nbsp; exception LockProtection {};
&nbsp; void CommitCommand() raises(LockProtection);
&nbsp;};
};</pre>
</div>
could be used caught as
<div class="fragment">
<pre>from SALOMEDS import StudyBuilder;
my_StudyBuilder=...
try:
&nbsp; my_StudyBuilder.CommitCommand();
except StudyBuilder.LockProtection,value:
&nbsp; print "Error! Study is locked for modifications"</pre>
</div>

<p><br><b><i><a href="#contents">Back to the contents</a></i></b><b><i><a href="#contents"></a></i></b>
<p><a NAME="subsection6"></a>
<h3>
Mapping for Enumeration Types</h3>
An enumeration is mapped into a number of constant objects in the name
space where the enumeration is defined. An application may only test for
equivalence of two enumeration values, and not assume that they behave
like numbers. For example, the definition
<div class="fragment">
<pre>module VISU {
&nbsp;interface PrsObject{
&nbsp;
&nbsp; enum PrsObjType{ TCURVE, TTABLE, TMESH, TCONTAINER,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TSCALARMAP, TISOSURFACE, TDEFORMEDSHAPE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCUTPLANES, TVECTORS };
&nbsp;};
};</pre>
</div>
introduces the objects
<div class="fragment">
<pre>from VISU import PrsObject
VISU.PrsObjType.TCURVE,VISU.PrsObjType.TTABLE,VISU.PrsObjType.TMESH,VISU.PrsObjType.TCONTAINER,
VISU.PrsObjType.TSCALARMAP,VISU.PrsObjType.TISOSURFACE,VISU.PrsObjType.TDEFORMEDSHAPE,VISU.PrsObjType.TCUTPLANES,
VISU.PrsObjType.TVECTORS</pre>
</div>
<b><i><a href="#contents">Back to the contents</a></i></b>
<p><a NAME="subsection7"></a>
<h3>
Mapping for Structured Types</h3>
An IDL struct definition is mapped into a Python class or type. For each
field in the struct, there is a corresponding attribute in the class with
the same name as the field. The constructor of the class expects the field
values, from left to right. For example, the IDL definition
<div class="fragment">
<pre>struct SDate {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short Second;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short Minute;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short Hour;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short Day;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short Month;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short Year;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</pre>
</div>
could be used in the Python statements
<div class="fragment">
<pre>Date=SDate(30, 12, 15, 26, 1, 79)
print Date.Second,Date.Minute,Date.Hour,Date.Day,Date.Month,Date.Year</pre>
</div>

<address>
<b><i><a href="#contents">Back to the contents</a></i></b></address>

</body>
<!-- Generated by Doxygen 1.2.14 -->
</html>
