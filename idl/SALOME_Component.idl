//  Copyright (C) 2003  OPEN CASCADE, EADS/CCR, LIP6, CEA/DEN,
//  CEDRAT, EDF R&D, LEG, PRINCIPIA R&D, BUREAU VERITAS 
// 
//  This library is free software; you can redistribute it and/or 
//  modify it under the terms of the GNU Lesser General Public 
//  License as published by the Free Software Foundation; either 
//  version 2.1 of the License. 
// 
//  This library is distributed in the hope that it will be useful, 
//  but WITHOUT ANY WARRANTY; without even the implied warranty of 
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
//  Lesser General Public License for more details. 
// 
//  You should have received a copy of the GNU Lesser General Public 
//  License along with this library; if not, write to the Free Software 
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA 
// 
// See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
//
//
//
//  File   : SALOME_Component.idl
//  Author : Paul RASCLE, EDF
//  $Header: 

#ifndef _SALOME_COMPONENT_IDL_
#define _SALOME_COMPONENT_IDL_

/*! \brief
This is a package of interfaces used for connecting new components to %SALOME
application. It also contains a set of interfaces used for management of %MED
component in %SALOME application.
*/
module Engines
{
  /*! 
    A byte stream which is used for binary data transfer between different
    components
  */
  typedef sequence<octet> TMPFile;  
  
  /*!
    General Key Value Structure to set or get properties, for component
  */
  struct KeyValuePair
  {
    string key;
    any value;
  };

  typedef sequence<KeyValuePair> FieldsDict;

  interface Component ;
  interface fileRef ;
  interface fileTransfer ;

  /*! \brief Interface of the %Container.
  This interface defines the process of loading and registration
  of new components in %SALOME application
  */

  interface Container
  {

    /*!
      Loads a new component class (dynamic library).
      \param componentName like COMPONENT, (Python or C++ implementation)
                           try to make a Python import of COMPONENT,
                           then a lib open of libCOMPONENTEngine.so
      \return true if load successfull or already done, false otherwise
    */
    boolean load_component_Library(in string componentName);

    /*!
      Creates a new servant instance of a component.
      Component library must be loaded.
      \param componentName Name of the component which will be registered
                           in Registry and Name Service,
                         (instance number suffix added to the registered name)
      \param studyId        0 if instance is not associated to a study, 
                            >0 otherwise (== study id)
      \return a loaded component
    */
    Engines::Component create_component_instance(in string componentName,
                                                 in long studyId);

    /*!
      Finds a servant instance of a component
      \param registeredName  Name of the component in Registry or Name Service,
                             without instance suffix number
      \param studyId        0 if instance is not associated to a study, 
                            >0 otherwise (== study id)
      \return the first instance found with same studyId
    */
    Component find_component_instance(in string registeredName,
				      in long studyId);

    /*!
      Find a servant instance of a component, or create a new one.
      Loads the component library if needed.
      Only applicable to multiStudy components.
      \param nameToRegister Name of the component which will be registered
                            in Registry (or Name Service)
      \param componentName  Name of the constructed library of the %component
                            (not used any more, give empty string)
      \return a loaded component
    */
    Component load_impl(in string nameToRegister,
			in string componentName);

    /*!
      Stops the component servant, and deletes all related objects
      \param component_i     Component to be removed
    */
    void remove_impl(in Component component_i);

    /*!
      Discharges all components from the container.
    */
    void finalize_removal() ;

    /*!
      Determines whether the server has been loaded or not.
    */
    void ping();

    /*!
      Name of the %container
    */
    readonly attribute string name ;

    /*!
      Shutdown the Container process.
    */
    oneway void Shutdown();

    /*!
      Returns the hostname of the container
    */
    string getHostName();

    /*!
      Returns the PID of the container
    */
    long getPID();

    /*!
      Returns True if the %container has been killed.
      Kept for Superv compilation but can't work, unless oneway...
      TO REMOVE !
    */
    boolean Kill_impl() ;

    /*!
      returns a fileRef object if origFileName exists and is readable
      else returns null object. Only one fileRef is created for a given
      file name, so, several calls with the same file name returns the 
      same object.
    */
    fileRef createFileRef(in string origFileName);

    /*!
      returns a fileTransfer object used to copy files from the container
      machine to the clients machines. Only one fileTransfer instance is
      created in a container.
    */
    fileTransfer getFileTransfer();

  };



  /*! \brief Interface of the %component.
  This interface is used for interaction between the %container and the
  %component and between the components inside the container.
  */
  interface Component
  {
    /*!
      The name of the instance of the %Component
    */
    readonly attribute string instanceName ;

    /*!
      The name of the interface of the %Component
    */
    readonly attribute string interfaceName ;

    /*!
      Determines whether the server has already been loaded or not.
    */
    void ping();

//     /*!
//       Set study associated to component instance
//       \param studyId
//       (=0:  multistudy component instance,
//        >0: study id associated to this instance
//       \return false if already set with a different value (change not possible)
//     */
//     boolean setStudyId(in long studyId);

    /*!
      get study associated to component instance
      \return -1: not initialised (Internal Error)
               0: multistudy component instance
              >0: study id associated to this instance
    */
    long getStudyId();

    /*!
      Deactivates the %Component.
      -- TO BE USED BY CONTAINER ONLY (Container housekeeping) --
      use remove_impl from Container instead !
    */
    void destroy() ;

    /*!
      Returns the container that the %Component refers to.
    */
    Container GetContainerRef() ;

    /*!
      Gives a sequence of (key=string,value=any) to the component. 
      Base class component stores the sequence in a map.
      The map is cleared before.
      This map is for use by derived classes. 
    */
    void setProperties(in FieldsDict dico);

    /*!
      returns a previously stored map (key=string,value=any) as a sequence.
      See setProperties(in FieldsDict dico).
    */
    FieldsDict getProperties();

    /*!
      This method is used by the %SUPERVISOR component. It sets the names of
      the graph and of the node.
      \param aGraphName Name of graph
      \param aNodeName  Name of node
    */
    void Names( in string aGraphName , in string aNodeName ) ;

    /*!
      Returns True if the %Component has been killed.
    */
    boolean Kill_impl() ;

    /*!
      Returns True if the activity of the %Component has been stopped.
      (It's action can't be resumed)
    */
    boolean Stop_impl() ;

    /*!
      Returns True if the activity of the %Component has been suspended.
      (It's action can be resumed)
    */
    boolean Suspend_impl() ;

    /*!
      Returns True if the activity of the %Component has been resumed.
    */
    boolean Resume_impl() ;

    /*!
      Returns the Cpu used (long does not run with python !...)
    */
    long CpuUsed_impl() ;
    
    /*!
      Returns a python script, which is being played back reproduces
      the data model of component
    */    
    TMPFile DumpPython(in Object theStudy,
		       in boolean isPublished, 
		       out boolean isValidScript); 

  } ;

  /*!
    A block of binary data used for file transfer. The maximum size of the
    block is defined on server side.
   */
  typedef sequence<octet> fileBlock;

  /*! \brief Interface of fileTransfer.
     The fileTransfer and fileRef interfaces provide a file transfer service
     between different computers.
  */
  interface fileTransfer
  {
    /*!
      open method returns a key (fileId) that identifies the structure
      (ex: C FILE), associated to the original file on the server.
      The structure is created by a container for transfer of files availables
      on the computer which runs the container.
      Each open gives a unique fileId, to allow concurrent reads of the same
      File.
    */
    long open(in string fileName);

    /*!
    when the file transfer is finished, close method releases structures 
    created by open method, identified by fileId.
    */
    void close(in long fileId);

    /*!
      Get successive blocks of octets from the original file.
      The last block is empty, and identifies the end of file.
    */
    fileBlock getBlock(in long fileId);
  };

  /*! \brief Interface of fileTransfer.
     The fileTransfer and fileRef interfaces provide a file transfer service
     between different computers.

     A fileRef object is associated to an original file (origFileName) on a
     machine (refMachine).
     It is created by a container (factoryServer) on refMachine,
     with createFileRef(in string origFileName) method.
     The fileRef object maintains a list of (machine,filename) for copies. 
     If a copy exists on myMachine, getRef(myMachine) returns the file name
     of the copy on myMachine, else returns empy string.
     If there is no copy on myMachine, method getFileTransfer() from container
     factoryServer on refMachine provides a fileTransfer object dedicated to
     CORBA file copy.
     After the copy, addRef(myMachine, localFileNameOnMyMachine) registers
     the file name of the copy on myMachine.
  */
  interface fileRef
  {
    readonly attribute string origFileName;
    readonly attribute string refMachine;

    Container getContainer();

    boolean addRef(in string machine,
		in string fileName);

    string getRef(in string machine);
  };

} ;

#endif
